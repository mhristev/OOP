1. Класове и обекти 
    - дефиниране на класове 
            class Foo{ int x_, y_;   };
    - капсулация 
            public - достъпно е за всички 
            private - достъпни променливи само в член функциите 
            private - !!!!!!!!!!!!!!!!!!
    - член функции и член променливи    
            Член функциите се поделят между всички инстанции на даден клас. Тоест се съдържа само едно копие на член функция в програмата и обектите от клас ползват нея 
    - Конструктори
            инициализират член променливите в класа      Foo(int x, int y) : x_(x), y_(y){} (this->x_ = x; this->y_ = y)
            може да имаме няколко конструктора 
            конструктор по подразбиране - без аргументи, изпълнява се всеки път, когато не подаваме аргументи при създаване на обект
    -Friend
            дава достъп на функция, дефинирана извън класа, да достъпва член променливи
            class Foo{
                int x; //private
                friend void printX(Foo& foo);
            }; 

            void printX(Foo& foo){ 
                cout << foo.x << endl;
            }
    -Деструктор
            - използва се когато имаме нужда да освободим памет, която е била заделена в обекта
            - освобождават ресурсите, използвани в обекта
            - извикват се автоматично при унищожаване на обекта
            - Най-честата му употреба е да освободи заделената в конструктора динамична памет

            class Foo{
                int size_;
                int *bar_;
                public:
                    Foo(int size) : size_(size), bar_(new int[size]){}       new (заделяме памет) int[] - от какъв тип и в скобите пишем колко

                    ~Foo(void){
                        delete [] bar_;
                    }
            }

    - Копиращ Конструктор
            -  член функция, която инициализира обект от същия клас

                Foo(const Foo &foo); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                Foo foo1(10, 12); // normal constructor
                Foo foo2 = foo1; //copy constructor called
                foo2 = foo1 // we dont call copy constructor here 

            - често дефинираме такъв, когато имаме пойнтъри в класа 
2. Указател "this"
    -всяка нестатична член функция получава този указател като допълнителен аргументи
    -каскадно извикване на функции 

    class Foo{
        int x;
        int y;
        public:
            Foo& set_x(int x){
                this->x = x;
                return *this;
            }

            Foo& set_y(int y){
                this->y = y;
                return *this;
            }
    }   

    Foo f;
    f.set_x(1).set_y(2); //каскадно извикване 
    // set_x() връща препратка към обекта, който е извикан, тоест когато set_x() върне "this" върху "f", ние можем да извикаме set_y() и ще се получи без проблеми

    -връщаме референции към обект за каскадно извикване 

3. Статични член променливи и статични член функции 
    -статичните член променливи имат само по едно копие за разлика от нестатичните член променливи
    -те съществуват независимо от това дали са създадени инстанции на даден клас
    -инициализират се извън класа

    class Foo{
        static int count;
        ...
    };

    int Foo::count = 0;

    -при извикване на статична член-функция, тя не се свързва с конкретна инстанция на класа. Поради тов не може директно да се използват нестатични член функции
    -за да се извика статична член функция не е необходим обект от класа
    -викат се директно, чрез името на класа, в който са дефинирани
    -имат пълен достъп до членовете на класа

        class Foo{
            int x;
            public:
                static void printX(Foo& foo){
                    cout << foo.x << endl;
                }
        };
        Foo foo;
        foo.x = 2;
        Foo::printX(foo);

4. Константи
    -константни променливи, константни обекти, константни член-променливи, константни методи, константни указатели
    -const прави обекта да не може да се променя
    -грешка ако се опитаме да променим const, винаги трябва да се инициализират
    
        const Foo foo(10, 12); // const Foo with const variables 
        foo.set_x(3); // error we cant change const variables

    - указатели
        char str1[] = "hello";
        char str2[] = "hell";

        const char* pc = str1; // we cant change the contents of the array, (const string)
        pc[2] = 'a'; // ERROR 
        pc = str2; // OK 

        char *const cp = str1; // string with constant pointer to object we cant change to where it points to
        cp[2] = 'a'; // OK
        cp = str2 // ERROR

        const char *const cps = str1; // we cant change either where it points to or the content in the pointer 

    - Константни член функции
        -когато член функция е const, то нейната дефиниция не може да променя състоянието на обекта и го карантираме пред компилатора

        double get_x() const{
            return x_;
        }

        -не може да променя състоянието на обекта върху който е извикана
        -при гетъри се използва например, те не променят стойноста на дадена член променлива

5. Предефиниране на оператори

6. Динамична памет (new & delete)

    - Foo* ptr = new Foo(10, 22);
    - Foo* array = new Foo[10]; //aray of Foo's

    cout << ptr->get_x() << endl; //print 10
    cout << array->get_x() << endl; // print array[0].x 

    - delete ptr1; // изтриване на единични обекти
    - delete [] array; // изтриване на масиви от Foo








